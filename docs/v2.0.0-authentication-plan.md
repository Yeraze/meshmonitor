# MeshMonitor v2.0.0 - Authentication & Authorization Implementation Plan

**Version:** 2.0.0
**Branch:** feature/v2.0.0-authentication
**Status:** Planning
**Date:** 2025-10-08

---

## Executive Summary

This document outlines the complete implementation plan for adding authentication and authorization to MeshMonitor. Version 2.0.0 introduces a dual authentication system supporting both built-in username/password authentication and optional OpenID Connect (OIDC) integration, along with granular per-tab permissions.

### Key Features

- **Dual Authentication Modes:**
  - Built-in authentication with bcrypt-hashed passwords
  - Optional OIDC integration for enterprise SSO

- **Granular Permissions:**
  - Separate Read and Write permissions per tab
  - Per-user permission management
  - Admin role with full access

- **Anonymous Access:**
  - Dashboard (read-only)
  - Node List and Map (read-only)

- **User Management:**
  - Admin interface for user management
  - Auto-creation of OIDC users with default permissions
  - First-run admin setup

---

## Authentication Strategy

### Authentication Modes

The system supports three authentication modes via the `AUTH_MODE` environment variable:

1. **`local`** - Only built-in username/password authentication
2. **`oidc`** - Only OpenID Connect authentication
3. **`both`** - Users can choose either method

### Permission Model

Each tab in the application has separate **Read** and **Write** permissions:

| Tab | Resource ID | Description |
|-----|-------------|-------------|
| Dashboard | `dashboard` | View statistics and system information |
| Nodes | `nodes` | View and manage mesh nodes |
| Messages | `messages` | Send and receive mesh messages |
| Settings | `settings` | Application settings |
| Configuration | `configuration` | Device configuration |
| Info | `info` | Telemetry and network information |
| Automation | `automation` | Automated tasks and announcements |

**Special Permissions:**
- **Anonymous users** can read `dashboard` and `nodes` without authentication
- **Admin users** have full read/write access to all resources
- **Admin-only operations** (purge, user management) require admin role

---

## Database Schema Changes

### New Tables

#### users
```sql
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE NOT NULL,
  password_hash TEXT,              -- NULL for OIDC users
  email TEXT,
  display_name TEXT,
  auth_provider TEXT NOT NULL DEFAULT 'local',  -- 'local' or 'oidc'
  oidc_subject TEXT UNIQUE,        -- OIDC sub claim
  is_admin BOOLEAN DEFAULT 0,
  is_active BOOLEAN DEFAULT 1,
  created_at INTEGER NOT NULL,
  last_login_at INTEGER,
  created_by INTEGER,              -- User who created this account
  FOREIGN KEY (created_by) REFERENCES users(id)
);

CREATE INDEX idx_users_username ON users(username);
CREATE INDEX idx_users_oidc_subject ON users(oidc_subject);
CREATE INDEX idx_users_auth_provider ON users(auth_provider);
```

#### permissions
```sql
CREATE TABLE permissions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  resource TEXT NOT NULL,          -- 'dashboard', 'nodes', 'messages', etc.
  can_read BOOLEAN DEFAULT 0,
  can_write BOOLEAN DEFAULT 0,
  granted_at INTEGER NOT NULL,
  granted_by INTEGER,              -- User who granted this permission
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
  FOREIGN KEY (granted_by) REFERENCES users(id),
  UNIQUE(user_id, resource)
);

CREATE INDEX idx_permissions_user_id ON permissions(user_id);
CREATE INDEX idx_permissions_resource ON permissions(resource);
```

#### sessions
```sql
CREATE TABLE sessions (
  sid TEXT PRIMARY KEY,
  sess TEXT NOT NULL,              -- JSON session data
  expire INTEGER NOT NULL
);

CREATE INDEX idx_sessions_expire ON sessions(expire);
```

#### audit_log
```sql
CREATE TABLE audit_log (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER,
  action TEXT NOT NULL,            -- 'login', 'logout', 'create_user', etc.
  resource TEXT,                   -- Resource affected
  details TEXT,                    -- JSON details
  ip_address TEXT,
  timestamp INTEGER NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE INDEX idx_audit_log_user_id ON audit_log(user_id);
CREATE INDEX idx_audit_log_timestamp ON audit_log(timestamp);
CREATE INDEX idx_audit_log_action ON audit_log(action);
```

---

## Implementation Phases

### Phase 1: Database & Models

**Files to Create:**
- `src/server/migrations/001_add_auth_tables.ts` - Migration script
- `src/server/models/User.ts` - User model with methods
- `src/server/models/Permission.ts` - Permission model
- `src/types/auth.ts` - Authentication types
- `src/types/permission.ts` - Permission types

**Database Service Updates:**
- Add user CRUD operations
- Add permission management methods
- Add audit logging methods
- Add first-run detection and admin setup

**First-Run Setup:**
```typescript
// On first run (no users exist):
1. Generate random password (20 chars, alphanumeric + symbols)
2. Create admin user:
   - Username: 'admin' (or from ADMIN_USERNAME env)
   - Password: generated password
   - is_admin: true
3. Grant all permissions to admin
4. Log password to console and audit log
5. Set 'setup_complete' flag in settings
```

---

### Phase 2: Backend Authentication

#### 2.1 Built-in Authentication

**File:** `src/server/auth/localAuth.ts`

```typescript
import bcrypt from 'bcrypt';

const SALT_ROUNDS = 12;

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, SALT_ROUNDS);
}

export async function verifyPassword(
  password: string,
  hash: string
): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

export async function createUser(
  username: string,
  password: string,
  email?: string,
  isAdmin: boolean = false
): Promise<User> {
  // Validate password strength
  // Hash password
  // Create user in database
  // Create default permissions
  // Return user
}

export async function authenticateUser(
  username: string,
  password: string
): Promise<User | null> {
  // Find user by username
  // Verify password
  // Update last_login_at
  // Return user or null
}
```

**Dependencies:**
- `bcrypt` or `bcryptjs`

#### 2.2 OIDC Authentication

**File:** `src/server/auth/oidcAuth.ts`

```typescript
import * as client from 'openid-client';

let oidcConfig: client.Configuration | null = null;

export async function initializeOIDC(): Promise<void> {
  if (!process.env.OIDC_ISSUER) {
    logger.info('OIDC not configured, skipping initialization');
    return;
  }

  const issuer = new URL(process.env.OIDC_ISSUER);
  const clientId = process.env.OIDC_CLIENT_ID!;
  const clientSecret = process.env.OIDC_CLIENT_SECRET!;

  oidcConfig = await client.discovery(
    issuer,
    clientId,
    undefined,
    client.ClientSecretPost(clientSecret)
  );
}

export async function handleOIDCCallback(
  code: string,
  state: string,
  codeVerifier: string
): Promise<User> {
  // Exchange code for tokens
  // Validate ID token
  // Extract claims (sub, email, name)
  // Create or update user in database
  // Return user
}

export function isOIDCEnabled(): boolean {
  return oidcConfig !== null;
}
```

**Dependencies:**
- `openid-client`

#### 2.3 Session Management

**File:** `src/server/auth/sessionConfig.ts`

```typescript
import session from 'express-session';
import createSqliteStore from 'connect-sqlite3';

const SqliteStore = createSqliteStore(session);

export const sessionConfig: session.SessionOptions = {
  store: new SqliteStore({
    db: 'sessions.db',
    dir: './data'
  }),
  secret: process.env.SESSION_SECRET || 'change-me-in-production',
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: parseInt(process.env.SESSION_MAX_AGE || '86400000') // 24h
  }
};

// Extend session type
declare module 'express-session' {
  interface SessionData {
    userId: number;
    username: string;
    authProvider: 'local' | 'oidc';
    isAdmin: boolean;
  }
}
```

**Dependencies:**
- `express-session`
- `connect-sqlite3`
- `@types/express-session`

#### 2.4 Authentication Middleware

**File:** `src/server/auth/authMiddleware.ts`

```typescript
import { Request, Response, NextFunction } from 'express';

// Attach user to request if authenticated
export function optionalAuth() {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (req.session.userId) {
      req.user = await getUserById(req.session.userId);
    }
    next();
  };
}

// Require authentication
export function requireAuth() {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (!req.session.userId) {
      return res.status(401).json({
        error: 'Authentication required',
        code: 'UNAUTHORIZED'
      });
    }
    req.user = await getUserById(req.session.userId);
    next();
  };
}

// Require specific permission
export function requirePermission(resource: string, action: 'read' | 'write') {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (!req.session.userId) {
      return res.status(401).json({
        error: 'Authentication required',
        code: 'UNAUTHORIZED'
      });
    }

    const user = await getUserById(req.session.userId);

    // Admins have all permissions
    if (user.is_admin) {
      req.user = user;
      return next();
    }

    const hasPermission = await checkPermission(user.id, resource, action);
    if (!hasPermission) {
      return res.status(403).json({
        error: 'Insufficient permissions',
        code: 'FORBIDDEN',
        required: { resource, action }
      });
    }

    req.user = user;
    next();
  };
}

// Require admin role
export function requireAdmin() {
  return async (req: Request, res: Response, next: NextFunction) => {
    if (!req.session.userId) {
      return res.status(401).json({
        error: 'Authentication required',
        code: 'UNAUTHORIZED'
      });
    }

    const user = await getUserById(req.session.userId);
    if (!user.is_admin) {
      return res.status(403).json({
        error: 'Admin access required',
        code: 'FORBIDDEN'
      });
    }

    req.user = user;
    next();
  };
}
```

#### 2.5 Authentication Routes

**Added to:** `src/server/server.ts`

```typescript
// Built-in authentication
apiRouter.post('/auth/login', async (req, res) => {
  // Authenticate user
  // Create session
  // Return user info
});

apiRouter.post('/auth/logout', (req, res) => {
  // Destroy session
  // Return success
});

apiRouter.get('/auth/status', optionalAuth(), (req, res) => {
  // Return current user info or null
});

apiRouter.post('/auth/change-password', requireAuth(), async (req, res) => {
  // Verify current password
  // Update password
  // Return success
});

// OIDC authentication
apiRouter.get('/auth/oidc/login', async (req, res) => {
  // Generate PKCE challenge
  // Redirect to OIDC provider
});

apiRouter.get('/auth/oidc/callback', async (req, res) => {
  // Handle OIDC callback
  // Create/update user
  // Create session
  // Redirect to app
});

// First-run setup
apiRouter.post('/auth/setup', async (req, res) => {
  // Only allowed if setup not complete
  // Change admin password
  // Mark setup complete
});
```

#### 2.6 User Management Routes

```typescript
// List all users (admin only)
apiRouter.get('/users', requireAdmin(), async (req, res) => {
  const users = await getAllUsers();
  res.json(users);
});

// Get user details (admin only)
apiRouter.get('/users/:id', requireAdmin(), async (req, res) => {
  const user = await getUserById(parseInt(req.params.id));
  res.json(user);
});

// Create user (admin only, local auth)
apiRouter.post('/users', requireAdmin(), async (req, res) => {
  const { username, password, email, isAdmin } = req.body;
  const user = await createUser(username, password, email, isAdmin);
  res.json(user);
});

// Update user (admin only)
apiRouter.put('/users/:id', requireAdmin(), async (req, res) => {
  const { email, displayName, isActive } = req.body;
  const user = await updateUser(parseInt(req.params.id), {
    email,
    displayName,
    isActive
  });
  res.json(user);
});

// Delete/deactivate user (admin only)
apiRouter.delete('/users/:id', requireAdmin(), async (req, res) => {
  await deactivateUser(parseInt(req.params.id));
  res.json({ success: true });
});

// Promote/demote admin (admin only)
apiRouter.put('/users/:id/admin', requireAdmin(), async (req, res) => {
  const { isAdmin } = req.body;
  await updateUserAdmin(parseInt(req.params.id), isAdmin);
  res.json({ success: true });
});

// Get user permissions (admin only)
apiRouter.get('/users/:id/permissions', requireAdmin(), async (req, res) => {
  const permissions = await getUserPermissions(parseInt(req.params.id));
  res.json(permissions);
});

// Update user permissions (admin only)
apiRouter.put('/users/:id/permissions', requireAdmin(), async (req, res) => {
  const { permissions } = req.body;
  await updateUserPermissions(parseInt(req.params.id), permissions);
  res.json({ success: true });
});

// Reset user password (admin only)
apiRouter.post('/users/:id/reset-password', requireAdmin(), async (req, res) => {
  const newPassword = generateRandomPassword();
  await resetUserPassword(parseInt(req.params.id), newPassword);
  res.json({ password: newPassword });
});
```

#### 2.7 Update Existing API Routes

**Public routes (anonymous allowed):**
```typescript
apiRouter.get('/nodes', optionalAuth(), ...)           // Can view anonymously
apiRouter.get('/config', ...)                          // Public
apiRouter.get('/health', ...)                          // Public
apiRouter.get('/connection', optionalAuth(), ...)      // Can view anonymously
```

**Protected routes with granular permissions:**
```typescript
// Dashboard
apiRouter.get('/stats', requirePermission('dashboard', 'read'), ...)

// Nodes
apiRouter.post('/nodes/refresh', requirePermission('nodes', 'write'), ...)
apiRouter.post('/nodes/:id/favorite', requirePermission('nodes', 'write'), ...)

// Messages
apiRouter.get('/messages', requirePermission('messages', 'read'), ...)
apiRouter.get('/messages/channel/:channel', requirePermission('messages', 'read'), ...)
apiRouter.get('/messages/direct/:id1/:id2', requirePermission('messages', 'read'), ...)
apiRouter.post('/messages/send', requirePermission('messages', 'write'), ...)
apiRouter.get('/channels', requirePermission('messages', 'read'), ...)

// Settings
apiRouter.get('/settings', requirePermission('settings', 'read'), ...)
apiRouter.post('/settings', requirePermission('settings', 'write'), ...)
apiRouter.delete('/settings', requirePermission('settings', 'write'), ...)
apiRouter.post('/settings/traceroute-interval', requirePermission('settings', 'write'), ...)

// Configuration
apiRouter.get('/config/current', requirePermission('configuration', 'read'), ...)
apiRouter.post('/config/device', requirePermission('configuration', 'write'), ...)
apiRouter.post('/config/lora', requirePermission('configuration', 'write'), ...)
apiRouter.post('/config/position', requirePermission('configuration', 'write'), ...)
apiRouter.post('/config/mqtt', requirePermission('configuration', 'write'), ...)
apiRouter.post('/config/neighborinfo', requirePermission('configuration', 'write'), ...)
apiRouter.post('/config/owner', requirePermission('configuration', 'write'), ...)
apiRouter.post('/device/reboot', requirePermission('configuration', 'write'), ...)

// Info (Telemetry/Traceroutes)
apiRouter.get('/telemetry/:nodeId', requirePermission('info', 'read'), ...)
apiRouter.get('/telemetry/available/nodes', requirePermission('info', 'read'), ...)
apiRouter.post('/traceroute', requirePermission('info', 'write'), ...)
apiRouter.get('/traceroutes/recent', requirePermission('info', 'read'), ...)
apiRouter.get('/route-segments/*', requirePermission('info', 'read'), ...)
apiRouter.delete('/route-segments/record-holder', requirePermission('info', 'write'), ...)
apiRouter.get('/neighbor-info', requirePermission('info', 'read'), ...)

// Automation
apiRouter.post('/announce/send', requirePermission('automation', 'write'), ...)
apiRouter.get('/announce/last', requirePermission('automation', 'read'), ...)

// Danger zone (admin only)
apiRouter.post('/purge/nodes', requireAdmin(), ...)
apiRouter.post('/purge/telemetry', requireAdmin(), ...)
apiRouter.post('/purge/messages', requireAdmin(), ...)
```

---

### Phase 3: Frontend Authentication

#### 3.1 Authentication Context

**File:** `src/contexts/AuthContext.tsx`

```typescript
import React, { createContext, useContext, useState, useEffect } from 'react';
import api from '../services/api';

interface User {
  id: number;
  username: string;
  email?: string;
  displayName?: string;
  authProvider: 'local' | 'oidc';
  isAdmin: boolean;
}

interface Permissions {
  [resource: string]: {
    read: boolean;
    write: boolean;
  };
}

interface AuthContextType {
  user: User | null;
  isAuthenticated: boolean;
  isAdmin: boolean;
  permissions: Permissions;
  login: (username: string, password: string) => Promise<void>;
  logout: () => Promise<void>;
  checkPermission: (resource: string, action: 'read' | 'write') => boolean;
  refreshAuth: () => Promise<void>;
}

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [permissions, setPermissions] = useState<Permissions>({});

  useEffect(() => {
    // Check auth status on mount
    refreshAuth();
  }, []);

  const refreshAuth = async () => {
    try {
      const response = await api.getAuthStatus();
      if (response.user) {
        setUser(response.user);
        setPermissions(response.permissions);
      } else {
        setUser(null);
        setPermissions({});
      }
    } catch (error) {
      setUser(null);
      setPermissions({});
    }
  };

  const login = async (username: string, password: string) => {
    await api.login(username, password);
    await refreshAuth();
  };

  const logout = async () => {
    await api.logout();
    setUser(null);
    setPermissions({});
  };

  const checkPermission = (resource: string, action: 'read' | 'write'): boolean => {
    if (!user) return false;
    if (user.isAdmin) return true;
    return permissions[resource]?.[action] || false;
  };

  return (
    <AuthContext.Provider value={{
      user,
      isAuthenticated: !!user,
      isAdmin: user?.isAdmin || false,
      permissions,
      login,
      logout,
      checkPermission,
      refreshAuth
    }}>
      {children}
    </AuthContext.Provider>
  );
};
```

#### 3.2 Login UI Components

**File:** `src/components/LoginButton.tsx`

Button in the header that triggers login modal or shows user menu.

**File:** `src/components/LoginModal.tsx`

Modal with:
- Username field
- Password field
- "Login" button
- "Login with OIDC" button (if OIDC enabled)
- Error display

**File:** `src/components/UserMenu.tsx`

Dropdown menu when logged in:
- Display name / username
- "Change Password" (local auth only)
- "Users" (admin only)
- "Logout"

#### 3.3 Users Management Tab

**File:** `src/components/UsersTab.tsx`

Admin-only tab showing:
- User list table with columns:
  - Username
  - Display Name
  - Email
  - Auth Provider
  - Admin
  - Active
  - Actions (Edit Permissions, Edit, Delete)
- "Add User" button (local auth only)
- Filters: Show all / Active only / Admin only

**File:** `src/components/UserPermissionsModal.tsx`

Modal for editing user permissions:
- Table of resources with Read/Write checkboxes
- Bulk actions: "Grant All Read", "Grant All Write", "Revoke All"
- "Save" and "Cancel" buttons

#### 3.4 Update Tab Navigation

**In:** `src/App.tsx`

```typescript
const { isAuthenticated, checkPermission } = useAuth();

// Determine which tabs to show
const tabs = [
  { id: 'dashboard', label: 'Dashboard', icon: '📊', public: true },
  { id: 'nodes', label: 'Nodes', icon: '📡', public: true },
  { id: 'messages', label: 'Messages', icon: '💬', requiresAuth: true, permission: 'messages' },
  { id: 'settings', label: 'Settings', icon: '⚙️', requiresAuth: true, permission: 'settings' },
  { id: 'configuration', label: 'Configuration', icon: '🔧', requiresAuth: true, permission: 'configuration' },
  { id: 'info', label: 'Info', icon: 'ℹ️', requiresAuth: true, permission: 'info' },
  { id: 'automation', label: 'Automation', icon: '🤖', requiresAuth: true, permission: 'automation' },
  { id: 'users', label: 'Users', icon: '👥', adminOnly: true }
];

const visibleTabs = tabs.filter(tab => {
  if (tab.public) return true;
  if (tab.adminOnly) return isAdmin;
  if (tab.requiresAuth && !isAuthenticated) return false;
  return checkPermission(tab.permission, 'read');
});
```

#### 3.5 Update API Service

**In:** `src/services/api.ts`

```typescript
// Add authentication methods
async login(username: string, password: string) {
  const response = await fetch(`${this.baseUrl}/api/auth/login`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({ username, password })
  });
  if (!response.ok) throw new Error('Login failed');
  return response.json();
}

async logout() {
  const response = await fetch(`${this.baseUrl}/api/auth/logout`, {
    method: 'POST',
    credentials: 'include'
  });
  return response.json();
}

async getAuthStatus() {
  const response = await fetch(`${this.baseUrl}/api/auth/status`, {
    credentials: 'include'
  });
  if (!response.ok) return { user: null, permissions: {} };
  return response.json();
}

// Add credentials to all existing requests
private async request(url: string, options: RequestInit = {}) {
  const response = await fetch(url, {
    ...options,
    credentials: 'include'
  });

  if (response.status === 401) {
    // Trigger login modal
    window.dispatchEvent(new CustomEvent('auth:required'));
  }

  if (response.status === 403) {
    // Show permission denied toast
    window.dispatchEvent(new CustomEvent('auth:forbidden'));
  }

  return response;
}
```

---

### Phase 4: Default Permissions

#### Admin User (First Run)
```typescript
const ADMIN_PERMISSIONS = {
  dashboard: { read: true, write: true },
  nodes: { read: true, write: true },
  messages: { read: true, write: true },
  settings: { read: true, write: true },
  configuration: { read: true, write: true },
  info: { read: true, write: true },
  automation: { read: true, write: true }
};
```

#### OIDC Auto-Created Users
```typescript
const OIDC_DEFAULT_PERMISSIONS = {
  dashboard: { read: true, write: false },
  nodes: { read: true, write: false },
  messages: { read: true, write: false },
  settings: { read: false, write: false },
  configuration: { read: false, write: false },
  info: { read: true, write: false },
  automation: { read: false, write: false }
};
```

#### Manually Created Local Users
Same as OIDC defaults, customizable during creation.

---

### Phase 5: Environment Configuration

#### Required Environment Variables

```bash
# Authentication Mode
AUTH_MODE=local              # Options: 'local', 'oidc', 'both'

# Built-in Authentication
ADMIN_USERNAME=admin         # Optional, defaults to 'admin'

# Session Configuration
SESSION_SECRET=CHANGE_ME_IN_PRODUCTION
SESSION_MAX_AGE=86400000     # 24 hours in milliseconds

# OIDC Configuration (Optional)
OIDC_ISSUER=https://your-oidc-provider.com
OIDC_CLIENT_ID=meshmonitor-client
OIDC_CLIENT_SECRET=your-client-secret
OIDC_REDIRECT_URI=http://localhost:8080/api/auth/oidc/callback
OIDC_SCOPES=openid profile email
OIDC_AUTO_CREATE_USERS=true  # Auto-create OIDC users with default permissions
```

#### Docker Compose Updates

**File:** `docker-compose.dev.yml`

```yaml
environment:
  - AUTH_MODE=local
  - SESSION_SECRET=${SESSION_SECRET:-generate-in-production}
  - OIDC_ISSUER=${OIDC_ISSUER:-}
  - OIDC_CLIENT_ID=${OIDC_CLIENT_ID:-}
  - OIDC_CLIENT_SECRET=${OIDC_CLIENT_SECRET:-}
  - OIDC_REDIRECT_URI=${OIDC_REDIRECT_URI:-}
```

#### .env.example

Create example file with all authentication variables.

---

### Phase 6: Security Features

#### Password Security
- **Hashing:** bcrypt with cost factor 12
- **Minimum length:** 8 characters
- **Strength requirements:** At least one letter and one number
- **Password change:** Requires current password verification
- **Admin reset:** Generates random secure password

#### Session Security
- **httpOnly:** Prevent XSS access to cookies
- **secure:** HTTPS only in production
- **sameSite:** 'strict' to prevent CSRF
- **maxAge:** Configurable session timeout
- **Store:** SQLite with automatic cleanup of expired sessions

#### Rate Limiting

```typescript
import rateLimit from 'express-rate-limit';

const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5,                    // 5 attempts
  message: 'Too many login attempts, please try again later'
});

apiRouter.post('/auth/login', loginLimiter, ...);
```

#### Audit Logging

Log all security-relevant events:
- User login/logout
- Failed login attempts
- User creation/deletion
- Permission changes
- Password changes
- Admin promotions
- Dangerous operations (purge, reboot)

---

### Phase 7: Testing & Validation

#### Unit Tests
- Password hashing/verification
- Permission checking logic
- OIDC token validation
- Session management

#### Integration Tests
- Login flow (local and OIDC)
- Permission enforcement
- User management operations
- First-run setup

#### Security Tests
- Rate limiting effectiveness
- Session hijacking prevention
- CSRF protection
- SQL injection prevention
- XSS prevention

#### Manual Testing Checklist
- [ ] First-run admin setup
- [ ] Admin password change
- [ ] Local user creation
- [ ] Local user login/logout
- [ ] OIDC login flow (if configured)
- [ ] OIDC user auto-creation
- [ ] Permission enforcement on API
- [ ] Permission enforcement on UI
- [ ] User management (create, edit, delete, permissions)
- [ ] Session expiration
- [ ] Rate limiting on login
- [ ] Audit log entries

---

## Migration Strategy

### For New Installations

1. Deploy v2.0.0
2. On first run, admin user is created with random password
3. Password is logged to console/logs
4. Admin logs in and changes password
5. Admin creates additional users or configures OIDC

### For Existing Installations

1. **Pre-Migration:**
   - Announce breaking change
   - Provide migration guide
   - Back up database

2. **Migration:**
   - Deploy v2.0.0
   - Database migration runs automatically
   - First-run creates admin user
   - Existing data remains accessible

3. **Post-Migration:**
   - Admin logs in with generated password
   - Admin changes password
   - Admin creates users for existing team members
   - Grant appropriate permissions

4. **Optional OIDC Setup:**
   - Configure OIDC environment variables
   - Restart application
   - Test OIDC login
   - Auto-created users get default permissions
   - Admin grants additional permissions as needed

---

## Dependencies to Add

### Backend
```json
{
  "dependencies": {
    "bcrypt": "^5.1.1",
    "express-session": "^1.18.1",
    "connect-sqlite3": "^0.9.13",
    "openid-client": "^5.7.0",
    "express-rate-limit": "^7.4.1"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/express-session": "^1.18.0"
  }
}
```

---

## File Structure

```
src/
├── server/
│   ├── auth/
│   │   ├── localAuth.ts              # Built-in authentication
│   │   ├── oidcAuth.ts               # OIDC authentication
│   │   ├── authMiddleware.ts         # Express middleware
│   │   └── sessionConfig.ts          # Session configuration
│   ├── models/
│   │   ├── User.ts                   # User model
│   │   └── Permission.ts             # Permission model
│   ├── migrations/
│   │   └── 001_add_auth_tables.ts    # Database migration
│   └── server.ts                     # Updated with auth routes
├── contexts/
│   └── AuthContext.tsx               # Frontend auth context
├── components/
│   ├── LoginButton.tsx               # Login button in header
│   ├── LoginModal.tsx                # Login form modal
│   ├── UserMenu.tsx                  # Logged-in user dropdown
│   ├── UsersTab.tsx                  # User management UI
│   └── UserPermissionsModal.tsx      # Permission editor
├── services/
│   └── api.ts                        # Updated with auth methods
└── types/
    ├── auth.ts                       # Auth type definitions
    └── permission.ts                 # Permission type definitions
```

---

## API Endpoints Summary

### Authentication
```
POST   /api/auth/login                # Local login
POST   /api/auth/logout               # Logout
GET    /api/auth/status               # Get current user
POST   /api/auth/change-password      # Change password
GET    /api/auth/oidc/login           # Initiate OIDC flow
GET    /api/auth/oidc/callback        # OIDC callback
POST   /api/auth/setup                # First-run password change
```

### User Management (Admin)
```
GET    /api/users                     # List users
GET    /api/users/:id                 # Get user
POST   /api/users                     # Create user
PUT    /api/users/:id                 # Update user
DELETE /api/users/:id                 # Delete user
PUT    /api/users/:id/admin           # Promote/demote admin
POST   /api/users/:id/reset-password  # Reset password
GET    /api/users/:id/permissions     # Get permissions
PUT    /api/users/:id/permissions     # Update permissions
```

---

## Risks & Mitigation

### Risk: Breaking Change
**Impact:** Existing deployments need configuration
**Mitigation:**
- Clear migration guide
- Feature flag for gradual rollout
- Backward compatibility during transition

### Risk: Session Storage Scaling
**Impact:** SQLite sessions may not scale well
**Mitigation:**
- Document Redis option for production
- Provide Redis configuration example
- Monitor session table size

### Risk: OIDC Configuration Complexity
**Impact:** Users may struggle with OIDC setup
**Mitigation:**
- Comprehensive documentation
- Example configurations for common providers
- Built-in auth as fallback

### Risk: First-Run Password Logging
**Impact:** Security concern if logs exposed
**Mitigation:**
- Clear warning in logs
- Recommend changing password immediately
- Auto-delete log after 24 hours

### Risk: Clock Skew with OIDC
**Impact:** Token validation failures
**Mitigation:**
- Document NTP requirement
- Add clock skew tolerance
- Clear error messages

---

## Success Criteria

- [ ] Admin can create and manage users
- [ ] Local authentication works for all users
- [ ] OIDC authentication works (when configured)
- [ ] Granular permissions enforce access control
- [ ] Anonymous users can view Dashboard and Nodes
- [ ] All existing functionality works when authenticated
- [ ] Security tests pass
- [ ] Documentation is complete
- [ ] Migration guide is clear
- [ ] Performance impact is minimal

---

## Documentation Deliverables

1. **Admin Guide:** User management, permission configuration
2. **OIDC Setup Guide:** Integration with common providers
3. **Migration Guide:** Upgrading from v1.x to v2.0
4. **Security Best Practices:** Password policies, session management
5. **API Documentation:** Updated with authentication requirements
6. **Troubleshooting Guide:** Common issues and solutions

---

## Timeline Estimate

| Phase | Estimated Time |
|-------|----------------|
| Phase 1: Database & Models | 2-3 days |
| Phase 2: Backend Auth | 3-4 days |
| Phase 3: Frontend Auth | 3-4 days |
| Phase 4: Default Permissions | 1 day |
| Phase 5: Environment Config | 1 day |
| Phase 6: Security Features | 2-3 days |
| Phase 7: Testing | 3-4 days |
| Documentation | 2-3 days |
| **Total** | **17-25 days** |

---

## Next Steps

1. ✅ Create feature branch
2. ✅ Update version to 2.0.0
3. ✅ Document implementation plan
4. Create database migration script
5. Implement user and permission models
6. Build authentication middleware
7. Update API routes with permissions
8. Create frontend authentication context
9. Build login UI components
10. Test and iterate

---

**Document Version:** 1.0
**Last Updated:** 2025-10-08
**Author:** Claude Code
**Status:** Ready for Implementation
