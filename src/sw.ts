/// <reference lib="webworker" />
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkOnly, CacheFirst, NetworkFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { CacheableResponsePlugin } from 'workbox-cacheable-response';

declare const self: ServiceWorkerGlobalScope;

// Precache all the assets generated by the build
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches
cleanupOutdatedCaches();

// CRITICAL: Always fetch HTML from network to get latest paths/BASE_URL
// This prevents serving stale cached HTML with wrong asset paths
registerRoute(
  ({ request }) => request.mode === 'navigate',
  new NetworkFirst({
    cacheName: 'html-cache',
    networkTimeoutSeconds: 3
  })
);

// Handle API routes (never cache)
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkOnly()
);

// Handle OpenStreetMap tiles (cache first)
registerRoute(
  ({ url }) => url.hostname.includes('tile.openstreetmap.org'),
  new CacheFirst({
    cacheName: 'openstreetmap-tiles',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 500,
        maxAgeSeconds: 60 * 60 * 24 * 30 // 30 days
      }),
      new CacheableResponsePlugin({
        statuses: [0, 200]
      })
    ]
  })
);

// ==========================================
// PUSH NOTIFICATION HANDLERS
// ==========================================

// Handle push events (background notifications)
self.addEventListener('push', (event) => {
  console.log('[Service Worker] Push received:', event);

  let notificationData = {
    title: 'MeshMonitor',
    body: 'You have a new notification',
    icon: '/logo.png',
    badge: '/logo.png',
    tag: undefined as string | undefined  // Will be set uniquely per notification
  };

  // Parse notification data from push payload
  if (event.data) {
    try {
      const data = event.data.json();
      notificationData = {
        title: data.title || notificationData.title,
        body: data.body || notificationData.body,
        icon: data.icon || notificationData.icon,
        badge: data.badge || notificationData.badge,
        tag: data.tag  // Use tag from payload, or undefined for unique notifications
      };
    } catch (error) {
      console.error('[Service Worker] Failed to parse push data:', error);
    }
  }

  // If no tag provided, use timestamp to ensure each notification is unique
  // This prevents macOS from replacing previous notifications
  const finalTag = notificationData.tag || `meshmonitor-${Date.now()}`;

  // CRITICAL for iOS: Use event.waitUntil() to keep service worker alive
  // iOS Safari requires this or the subscription gets cancelled after 3 notifications
  event.waitUntil(
    self.registration.showNotification(notificationData.title, {
      body: notificationData.body,
      icon: notificationData.icon,
      badge: notificationData.badge,
      tag: finalTag,
      requireInteraction: false  // Allow notifications to auto-dismiss
    } as NotificationOptions)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', (event) => {
  console.log('[Service Worker] Notification clicked:', event);

  event.notification.close();

  // Open or focus the MeshMonitor app
  event.waitUntil(
    self.clients.matchAll({ type: 'window', includeUncontrolled: true })
      .then((clientList) => {
        // Check if app is already open
        for (const client of clientList) {
          if (client.url.includes(self.registration.scope) && 'focus' in client) {
            return client.focus();
          }
        }

        // If app is not open, open it
        if (self.clients.openWindow) {
          return self.clients.openWindow(self.registration.scope);
        }
      })
  );
});

// Handle push subscription changes (e.g., subscription expired)
self.addEventListener('pushsubscriptionchange', (event) => {
  console.log('[Service Worker] Push subscription changed:', event);

  event.waitUntil(
    self.registration.pushManager.subscribe(event.oldSubscription?.options || { userVisibleOnly: true })
      .then((subscription) => {
        console.log('[Service Worker] Re-subscribed:', subscription);

        const p256dh = subscription.getKey('p256dh');
        const auth = subscription.getKey('auth');

        if (!p256dh || !auth) {
          throw new Error('Missing subscription keys');
        }

        // Send new subscription to backend
        return fetch('/api/push/subscribe', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            subscription: {
              endpoint: subscription.endpoint,
              keys: {
                p256dh: arrayBufferToBase64(p256dh),
                auth: arrayBufferToBase64(auth)
              }
            }
          })
        });
      })
      .catch((error) => {
        console.error('[Service Worker] Re-subscription failed:', error);
      })
  );
});

// Helper function to convert ArrayBuffer to Base64
function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer);
  let binary = '';
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

console.log('[Service Worker] MeshMonitor service worker with push notifications loaded');

// Skip waiting on install to activate new service worker immediately
self.addEventListener('install', (event) => {
  console.log('[Service Worker] Installing new service worker');
  event.waitUntil(self.skipWaiting());
});

// Claim all clients when activated
self.addEventListener('activate', (event) => {
  console.log('[Service Worker] Activating new service worker');
  event.waitUntil(
    self.clients.claim().then(() => {
      console.log('[Service Worker] Claimed all clients');
    })
  );
});
